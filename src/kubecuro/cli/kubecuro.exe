#!/usr/bin/env python3
"""
AKESO/KUBECURO UNIFIED CLI
--------------------------
High-fidelity manifest healing and diagnostics.
Maintains 1:1 parity between OSS (Akeso) and Enterprise (Kubecuro).

This module handles:
1. Identity detection and Bridge integration.
2. Argument parsing with specific USAGE patterns.
3. Advanced UI rendering with Rich (Panels, Groups, and Tables).
4. Dispatching to the Core Engine for auditing and reconciliation.

Changelog (2026-01-27):
- Added --kube-version flag for cluster version targeting
- Integrated cluster version validation and detection
- Enhanced version display with target K8s info
- Improved Pro/OSS feature differentiation for version detection
"""

import sys
import os
import json
import argparse
import logging
import platform  # Essential for authentic system telemetry
from typing import List

# Internal Core Modules - Infrastructure for healing and licensing
from akeso.core.engine import AkesoEngine
from akeso.core.bridge import AkesoBridge, ProStatus
from akeso.core.context import HealContext  # ‚úÖ ADDED: For version validation

# UI / UX Modules - High-fidelity terminal formatting
from akeso.ui.formatter import AkesoFormatter
from rich.console import Console, Group
from rich.table import Table
from rich.panel import Panel

# Global UI Controller for consistent terminal output
console = Console()
formatter = AkesoFormatter()
logger = logging.getLogger("akeso.cli")

# --- Metadata Constants ---
CORE_VERSION = "0.1.0-stable"
CATALOG_VERSION = "k8s-01.32-distilled"

def print_custom_header(invoked_as: str, is_pro: bool):
    """
    Displays the top-level application banner.
    Adjusts titles, subtitles, and border colors based on binary identity.
    
    Args:
        invoked_as (str): The name used to call the script (akeso/kubecuro).
        is_pro (bool): Pro license status for branding subtitiles.
    """
    console.print("")
    if invoked_as == "kubecuro":
        title = "üíé Kubecuro Enterprise"
        subtitle = "Logic Diagnostics & YAML Auto-Healer"
        border = "magenta"
        if not is_pro:
            # Acknowledge the OSS engine foundation when unlicensed
            subtitle += " (via Akeso OSS Foundation)"
    else:
        title = "üõ°Ô∏è Akeso OSS"
        subtitle = "High-Fidelity Kubernetes Manifest Healing"
        border = "cyan"

    banner_content = (
        f"[bold]{title:^54}[/bold]\n"
        f"[dim italic]{subtitle:^58}[/dim italic]"
    )
    
    console.print(Panel(
        banner_content, 
        border_style=border, 
        expand=False,
    ))

def print_version(invoked_as: str, is_pro: bool, cluster_version: str = None):
    """
    Displays the system information panel with a compact, professional layout.
    Utilizes a Group to combine a fixed-width metadata table with a 
    span-ready promotional footer, preventing 'canyon' whitespace or wrapping.
    
    Args:
        invoked_as: Command name (akeso/kubecuro)
        is_pro: Pro license status
        cluster_version: Target K8s version (if specified)
    """
    # Dynamic identity and styling
    tier = "Enterprise" if invoked_as == "kubecuro" else "OSS"
    border_color = "magenta" if invoked_as == "kubecuro" else "cyan"
    
    # Authentic Hardware and Software Telemetry
    sys_platform = f"{platform.system()} {platform.release()}"
    sys_arch = platform.machine()
    runtime_env = f"Python {platform.python_version()}"
    
    # Get target K8s version (from arg or default detection)
    if not cluster_version:
        cluster_version = HealContext._get_default_cluster_version()
    
    # Table 1: Technical Metadata (Key-Value Alignment)
    info_table = Table(box=None, show_header=False, padding=(0, 1))
    info_table.add_column(width=18, justify="left") # Fixed label width for tightness
    info_table.add_column(justify="left")           # Flexible for system strings
    
    info_table.add_row("Client Version:", f"[bold white]{CORE_VERSION}[/bold white]")
    info_table.add_row("Identity:", f"[bold {border_color}]{invoked_as.upper()}[/bold {border_color}] ({tier})")
    
    # Enhanced license status display
    if is_pro:
        badge, license_msg, color = AkesoBridge.get_pro_status_display()
        info_table.add_row("License Status:", f"[{color}]{badge}[/{color}]")
        info_table.add_row("", f"[dim]{license_msg}[/dim]")
        
        # Show trial usage details if in trial
        try:
            from akeso.pro import license as pro_license
            trial_status = pro_license.get_trial_status_display()
            
            # Only show if it's actually a trial (not paid license)
            if "Trial" in trial_status:
                console.print("\n[bold]Trial Usage:[/bold]")
                console.print(trial_status)
        except Exception:
            pass  # Gracefully skip if Pro not fully installed
    else:
        info_table.add_row("License Status:", "[dim]Community/Unlicensed[/dim]")
    
    info_table.add_row("Catalog Schema:", f"[yellow]{CATALOG_VERSION}[/yellow]")
    
    # ‚úÖ NEW: Show target K8s version
    info_table.add_row("Target K8s:", f"[green]{cluster_version}[/green]")
    
    info_table.add_row("Platform:", f"{sys_platform} ({sys_arch})")
    info_table.add_row("Runtime:", f"{runtime_env}")
    
    # Table 2: Promotional/Status Tip (Uses custom padding to avoid panel bottom-gap)
    tip_table = Table(box=None, show_header=False, padding=(1, 1, 0, 1))
    tip_table.add_column()
    
    if not is_pro:
        tip_text = "[bold]üí° Kubecuro Enterprise supports auto-detection from kubectl[/bold]"
    else:
        tip_text = "[dim]‚ú® Pro: Auto-detect cluster versions from kubectl/API[/dim]"
    
    tip_table.add_row(tip_text)

    # Combine tables into a renderable Group
    panel_group = Group(info_table, tip_table)

    console.print(Panel(
        panel_group, 
        title=f"[bold]Operational Context[/bold]", 
        border_style=border_color,
        padding=(0, 2),
        expand=False
    ))

def print_kubectl_help(invoked_as: str):
    """
    Displays the main help menu in a 'kubectl' inspired format.
    Ensures commands and options are logically grouped and scannable.
    """
    console.print("\n[bold cyan]‚îå‚îÄ COMMANDS[/bold cyan]")
    cmd_table = Table(show_header=False, box=None, padding=(0, 2, 0, 0))
    cmd_table.add_column(style="bold green", width=12)
    cmd_table.add_column(style="white")
    cmd_table.add_row("scan", "Audit manifests for logical issues (read-only)")
    cmd_table.add_row("heal", "Execute manifest reconciliation and healing")
    cmd_table.add_row("version", "Display detailed system and license details")
    cmd_table.add_row("auth", "Manage Kubecuro Enterprise authentication")
    console.print(cmd_table)

    console.print("\n[bold cyan]‚îå‚îÄ GLOBAL OPTIONS & FILTERS[/bold cyan]")
    opt_table = Table(show_header=False, box=None, padding=(0, 2, 0, 0))
    opt_table.add_column(style="yellow", width=24)
    opt_table.add_column(style="dim white")
    opt_table.add_row("-h, --help", "Show this help message")
    opt_table.add_row("-v, --version", "Display version information")
    opt_table.add_row("--kube-version VERSION", "Target K8s version (e.g., 1.28, v1.31)")  # ‚úÖ NEW
    opt_table.add_row("--catalog PATH", "Specify a custom K8s schema catalog")
    opt_table.add_row("--max-depth N", "Limit directory recursion depth (Default: 10)")
    opt_table.add_row("--ext LIST", "Process files with these extensions (Default: .yaml,.yml)")
    opt_table.add_row("-s, --summary-only", "Show aggregate stats (recommended for 100+ files)")
    console.print(opt_table)
    
    console.print(f"\n[bold magenta]üí° TIP[/bold magenta]")
    console.print(f"   Use [cyan bold]{invoked_as} <command> --help[/cyan bold] for subcommand specific flags.")
    console.print(f"   Override cluster version: [dim]AKESO_KUBE_VERSION=1.28 {invoked_as} heal ...[/dim]\n")

def main():
    """
    Primary orchestration logic for the CLI.
    """
    # Enable twin command creation (akeso ‚Üî kubecuro symlinks)
    AkesoBridge.ensure_dual_identity()
    
    # 1. Identity Gate: Determine if we are running as Akeso or Kubecuro
    try:
        invoked_as = AkesoBridge.get_invoked_command()
        
        # Get detailed Pro/Trial status
        status, message = AkesoBridge.check_pro_status()
        is_pro = status.is_usable()

        # Only show license warnings when user tries Pro features
        # Smart license warning system - only show when appropriate
        should_show_warning = False

        # Scenario 1: User is trying to use Pro-only features
        if getattr(args, 'harden', False):
            should_show_warning = True
            logger.debug("License warning triggered: Pro feature attempted (--harden)")

        # Scenario 2: User had Pro before AND 24 hours passed since last reminder
        elif AkesoBridge.has_pro_license_file() and AkesoBridge.should_show_daily_reminder():
            should_show_warning = True
            logger.debug("License warning triggered: Daily reminder for previous Pro user")

        # Only show warning if one of the scenarios triggered
        if should_show_warning and status.requires_user_action():
            AkesoBridge.notify_license_status(status, message)
            AkesoBridge.mark_reminder_shown()  # Record that we showed it
            logger.debug("License warning displayed and marked")
        else:
            logger.debug("License warning skipped (clean UX for regular usage)")

    except Exception as e:
        # Robust fallback for standalone development
        logger.debug(f"Identity detection failed: {e}")
        invoked_as = "akeso"
        is_pro = False
        status = None

    # 2. Argument Parser Configuration
    parser = argparse.ArgumentParser(prog=invoked_as, add_help=False)
    
    # Global cluster version flag (will be inherited by subparsers)
    parser.add_argument(
        "--kube-version",
        type=str,
        default=None,
        metavar="VERSION",
        dest="kube_version",
        help="Target Kubernetes version (e.g., 1.28, v1.31). Defaults to AKESO_KUBE_VERSION or v1.31."
    )
 
    # Existing global flags
    parser.add_argument("--catalog", default="catalog/k8s_v1_distilled.json")
    parser.add_argument("-h", "--help", action="store_true")
    parser.add_argument('-v', '--version', action='store_true')
    parser.add_argument('-s', '--summary-only', action='store_true',
                       help='Show aggregate stats instead of detailed table')
    
    subparsers = parser.add_subparsers(dest="command")
    
    def add_standard_flags(sub):
        """Helper to inject path arguments and search filters into sub-parsers."""
        sub.add_argument("--kube-version", type=str, default=None, metavar="VERSION", dest="kube_version", help="Target K8s version (e.g., 1.28, v1.31)")
        sub.add_argument("path", nargs="?")
        sub.add_argument("--max-depth", type=int, default=10)
        sub.add_argument("--ext", default=".yaml,.yml")
        sub.add_argument("-h", "--help", action="store_true")
        sub.add_argument("-s", "--summary-only", action="store_true",
                        help="Show aggregate stats (recommended for 100+ files)")

    # SCAN Command Setup
    scan_parser = subparsers.add_parser("scan", add_help=False)
    add_standard_flags(scan_parser)
    scan_parser.add_argument("--json", action="store_true")

    # HEAL Command Setup
    heal_parser = subparsers.add_parser("heal", add_help=False)
    add_standard_flags(heal_parser)
    heal_parser.add_argument("--dry-run", action="store_true")
    heal_parser.add_argument("--harden", action="store_true")
    heal_parser.add_argument("--check-deprecations", action="store_true",
                        help="Check for deprecated APIs only (no healing)")

    # Utility Commands
    subparsers.add_parser("version", add_help=False)
    auth_parser = subparsers.add_parser("auth", add_help=False)
    auth_parser.add_argument("--login", metavar="TOKEN")

    # 3. Parse input arguments
    args, unknown = parser.parse_known_args()

    # Validate cluster version early if provided
    target_cluster_version = None
    
    if args.kube_version:
        try:
            target_cluster_version = HealContext.set_cluster_version(args.kube_version)
        except ValueError as e:
            console.print(f"[bold red]‚ùå Invalid K8s version:[/bold red] {e}")
            sys.exit(1)
    
    # Unified version output for both command and flag
    if args.version or args.command == "version":
        print_version(invoked_as, is_pro, cluster_version=target_cluster_version)
        sys.exit(0)

    # 4. Contextual Help and Usage Intercepts
    if args.help or not args.command or (args.command in ["heal", "scan"] and not args.path):
        print_custom_header(invoked_as, is_pro)
        
        if args.command == "scan":
            console.print(f"\n[bold green]USAGE:[/bold green] [bold white]{invoked_as} scan <path>[/bold white] [options]")
            console.print("\n[bold cyan]AUDIT OPTIONS[/bold cyan]")
            console.print("  --json               Output audit results as JSON")
            console.print("  --kube-version VER   Target K8s version (e.g., 1.28)")
            console.print("  -s, --summary-only   Show aggregate statistics")
            console.print("\n[bold cyan]SEARCH FILTERS[/bold cyan]")
            console.print("  --max-depth N   Max directory levels to search (Default: 10)")
            console.print("  --ext LIST      Extensions to process (Default: .yaml,.yml)")
            
        elif args.command == "heal":
            console.print(f"\n[bold green]USAGE:[/bold green] [bold white]{invoked_as} heal <path>[/bold white] [options]")
            console.print("\n[bold cyan]RECONCILIATION OPTIONS[/bold cyan]")
            console.print("  --dry-run            Preview changes in diff format")
            console.print("  --kube-version VER   Target K8s version (e.g., 1.28)")
            console.print("  --harden             [PRO] Apply Shield security hardening")
            console.print("  -s, --summary-only   Show aggregate statistics (recommended for 100+ files)")
            console.print("\n[bold cyan]SEARCH FILTERS[/bold cyan]")
            console.print("  --max-depth N   Max directory levels to search (Default: 10)")
            console.print("  --ext LIST      Comma-separated extensions (Default: .yaml,.yml)")
            console.print("\n[bold yellow]üí° TIP:[/bold yellow]")
            console.print("  Set AKESO_KUBE_VERSION=1.28 to avoid repeating --kube-version")
            
        else:
            # Main high-level help menu
            print_kubectl_help(invoked_as)
            
        sys.exit(0)

    # 5. Pro-Feature Security Gate
    if getattr(args, 'harden', False) and not is_pro:
        AkesoBridge.notify_pro_required("Shield Security Hardening")
        sys.exit(0)

    # 6. Execution Engine Integration
    try:
        # Show cluster version info before processing
        if target_cluster_version:
            console.print(f"üéØ Target K8s: [bold green]{target_cluster_version}[/bold green]")
        else:
            detected_version = HealContext._get_default_cluster_version()
            console.print(f"üéØ Target K8s: [bold green]{detected_version}[/bold green] (default)")
            target_cluster_version = detected_version
        
        # Initialize the core logic engine with cluster version
        engine = AkesoEngine(
            workspace_path=".", 
            catalog_path=args.catalog,
            cluster_version=target_cluster_version  # Pass cluster version
        )
        
        # 'scan' is essentially a dry-run heal with audit-only output
        is_dry = (args.command == "scan") or (getattr(args, 'dry_run', False))
        extensions = [e.strip() for e in args.ext.split(",")]

        # Dispatch based on target type (Single file vs directory crawl)
        if os.path.isfile(args.path):
            result = engine.audit_and_heal_file(args.path, dry_run=is_dry)
            job_results = [result]
            
            # For single files, use display_report for detailed view
            formatter.display_report(result)
            
        else:
            job_results = engine.batch_heal(
                root_path=args.path, 
                extensions=extensions, 
                max_depth=args.max_depth,
                dry_run=is_dry
            )

            # 7. Output Result Formatting
            if getattr(args, 'json', False):
                # JSON output for automation/CI
                print(json.dumps(job_results, indent=2))
            else:
                # Use new formatter with summary-only support
                summary_mode = getattr(args, 'summary_only', False)
                formatter.print_final_table(job_results, summary_only=summary_mode)
            
            # Show trial usage warnings if approaching limits
            if is_pro:
                try:
                    from akeso.pro import license as pro_license
                    
                    # Check current status
                    current_status, msg = AkesoBridge.check_pro_status()
                    
                    # Only show warnings during active trial (not paid licenses)
                    if current_status == ProStatus.TRIAL_ACTIVE:
                        summary = pro_license.get_usage_summary()
                        
                        # Show warning if any feature is at 80%+ usage
                        high_usage_features = []
                        for feature, data in summary.items():
                            if data["percentage"] >= 80:
                                feature_name = feature.replace("_", " ").title()
                                high_usage_features.append(
                                    f"{feature_name}: {data['used']}/{data['limit']} ({data['percentage']}%)"
                                )
                        
                        if high_usage_features:
                            console.print(f"\n[yellow]‚ö†Ô∏è  Trial Usage Alert:[/yellow]")
                            for feat in high_usage_features:
                                console.print(f"  {feat}")
                        
                        # If any limit hit 100%, show upgrade prompt
                        if any(d["percentage"] >= 100 for d in summary.values()):
                            console.print("\n")
                            console.print(Panel(
                                "[bold yellow]üéâ Trial Limit Reached![/bold yellow]\n\n"
                                "You've successfully used Kubecuro Pro.\n\n"
                                "Upgrade now for unlimited features:\n"
                                "  ‚Ä¢ [cyan]https://kubecuro.dev/upgrade[/cyan]\n"
                                "  ‚Ä¢ Special: 20% off with code TRIAL20\n\n"
                                "[dim]Akeso OSS features remain unlimited.[/dim]",
                                border_style="yellow",
                                expand=False
                            ))
                except Exception as e:
                    logger.debug(f"Trial status check failed: {e}")
            
            # Contextual marketing nudge for OSS users
            if not is_pro and args.command != "scan":
                console.print(f"\n[dim]Healing complete. For auto-detection and multi-cluster profiles, try [bold magenta]Kubecuro Enterprise[/bold magenta].[/dim]")

    except Exception as e:
        # Centralized fatal error handling
        console.print(f"[bold red]Fatal Error:[/bold red] {e}")
        import traceback
        logger.error(traceback.format_exc())
        sys.exit(1)

if __name__ == "__main__":
    # Start the CLI lifecycle
    main()
